#include <iostream>
using namespace std;

void arrayExamples() {
    int a[10] = {1, 2, 3, 4};
    int b[10] = {1, 2, 3, 4};
    cout << a[1] << endl;
    // !!! cout << a[1000000] << endl;
    // !!! a = b;
    cout << (a == b) << endl;
    cout << (a == a) << endl;
    // !!! cin >> a;
    cout << a << endl;
}

void testArrays() {
    const int N = 100;
    int a[N];
    int n;
    do {
        cout << "Въведете брой на елементите: ";
        cin >> n;
    } while (n <= 0 || n > N);
    for(int i = 0; i < n; i++) {
        cout << "a[" << i << "] = ";
        cin >> a[i];
    }

    int sum = 0;

    for(int i = 0; i < n; i++)
        sum += a[i];

    cout << "Сумата на елементите е: " << sum << endl;

    cout << "Въведете число за търсене: ";
    int x;
    cin >> x;

    /* for е по-подходящ за задачи за всяко
    for(int i = 0; i < n; i++)
        if (a[i] == x)
            cout << "Числото " << x << " се среща в масива";
    */

    // цикъл за търсене
    int i = 0;
    // n == N, x не се среща в масива, тогава i == n, a[100]!!!
    while(i < n && a[i] != x)
        // инвариант: x не е равно на нито едно от a[0], a[1], ..., a[i]
        i++;
    // добър вариант (да): a[i] == x 
    // лош вариант   (не): i >= n
    cout << "Числото " << x;
    if (i == n)
        cout << " НЕ";
    cout << " се среща в масива" << endl;

    i = 0;
    while (i < n - 1 && a[i] <= a[i+1])
        i++;
    // добър вариант (да): i == n - 1    (няма нарушение)
    // лош   вариант (не): a[i] > a[i+1] (има нарушение)
    cout << "Редицата от елементите ";
    if (i < n - 1)
        cout << "НЕ ";
    cout << "е монотонно растяща" << endl;

    i = 0;
    int j = 1;
    while(i < n - 1 && a[i] != a[j]) {
        // инвариант: ???
        // сега трябва да проверим дали a[i] се среща в масива
        // от a[i+1] нататък
        j = i + 1;
        while(j < n && a[i] != a[j])
            // инвариант: a[i] не е равно на нито едно от a[0], a[1], ..., a[j]
            j++;
        //if (j == n) // не сме намерили съвпадение на a[i] с a[j] и трябва да продължим търсенето
        i++;
    }
    // добър вариант (да): i == n - 1, по-добре дали j == n
    // лош вариант   (не): a[i] == a[j]
    if (j == n)
        cout << "Числата в редицата са различни" << endl;
    else
        cout << "В редицата има повтарящи се числа" << endl;

    // сортиране по метода на пряката селекция
    for(int i = 0; i < n - 1; i++) {
        // инвариант: a[i] е първият елемент на неподредената част
        // сега трябва да намерим най-малкия елемент на неподредената част
        int imin = i;
        for(int j = i + 1; j < n; j++)
            // инвариант: ???
            if (a[j] < a[imin])
                imin = j;
        // вече знаем, че imin е индексът на най-малкия елемент в неподредената част
        // разменяме този елемент с първия елемент от неподредената част, a[i]
        int tmp = a[i];
        a[i] = a[imin];
        a[imin] = tmp;
    }
    // можем да спрем при i == n - 1
 
     for(int i = 0; i < n; i++)
        cout << "a[" << i << "] = " << a[i] << endl;
}

int main() {
    const int N = 100;
    int a[N] = { 0 }, b[N] = { 0 };
    int na, nb;
    do {
        cout << "Въведете брой на елементите в първия масив: ";
        cin >> na;
    } while (na <= 0 || na > N);
    for(int i = 0; i < na; i++) {
        cout << "a[" << i << "] = ";
        cin >> a[i];
    }
    do {
        cout << "Въведете брой на елементите във втория масив: ";
        cin >> nb;
    } while (nb <= 0 || nb > N);
    for(int i = 0; i < nb; i++) {
        cout << "b[" << i << "] = ";
        cin >> b[i];
    }

    // считаме, че елементите им са подредени в нарастващ ред
    int c[2*N];
    int i = 0, j = 0, k = 0;
    while (i < na && j < nb) // докато и в двата масива има още необработени елементи
        // инвариант: k е първият незаписан индекс в c и ... ???
        if (a[i] < b[j])
            // ще вземем от a
            c[k++] = a[i++];
        else
            // ще вземем от b
            c[k++] = b[j++];
    // i == na || j == nb
    // трябва да прехвърлим останалите елементи
    // a е свършил, трябва да прехвърлим оставащите от b
    while(j < nb)
        c[k++] = b[j++];
    // b е свършил, трябва да прехвърлим оставащите от a
    while(i < na)
        c[k++] = a[i++];

    for(int i = 0; i < na + nb; i++)
        cout << "c[" << i << "] = " << c[i] << endl;
    return 0;
}