# Кратка теория

## I. Променливи
В програмните езици данните се съхраняват в **променливи**. Всяка променлива притежава:

1. Име: a, b, myName, circle_radius. Името служи за уникален идентификатор, който си избираме за нашата променлива. Добра практика е имената на променливите да са значещи и да могат да бъдат разбрани от някой, който чете нашия код (например 'circleRadius' вместо 'r'). Също така има конвенции за стил изписване (например *snake case*: my_name, circle_radius, или *camel case*: myName, circleRadius).

2. Стойност: x = 3.14, myFacultyNumber = 1234.

3. Тип: 
>Типът на променливата определяме според стойностите, които искаме тя да приема.
   - цяло число (1, 1203, etc.)
   - десетично число (1.3, 45.12103, etc.)
   - символ (a, b, x, etc.)
   - булев (true (1), false(0))
   - символен низ (hey, program, hello world, etc.)

4. Размер: броят байтове, които заема променливата в паметта.

5. Адрес: мястото в паметта, където се пази. 
  
## II. Създаване на променливи

Начина за съзадаване на променлива е:

    <тип_на_променливата> <име_на_променливата> {= <стойност>}опц

>### Инициализация, декларация и дефиниция:
- Декларация е, когато създаваме променлива, без да ѝ присвоим стойност `int myAge;`
- Инициализация е, когато присвояваме на дадена променлива стойност при декларацията `int myAge = 20;`
- Дефиниция е, когато променливата вече е декларирана някъде, но няма зададена стойност и след дадено време решаваме, че ни трябва стойност и я задаваме там.
```c++
{
    int myAge;
    // one eternity later
    myAge = 20;
}
```

>### Преобразуване на променливи:
- Неявно преобразуване: 
```c++
double x = 6.9;
int y = x;
std::cout << y; //Извежда: 6
```
- Явно преобразуване: (тип)(<израз>)
```c++
int x = (int) (6.9 + 6.9);
double y = (double) (123 + 321);
std::cout << x << " " << y; //Извежда: 13 444
```
- Друг вид явно преобразуване:(static_cast<тип>(<променлива> или <израз>))
```c++
int x = static_cast<int>(6.9 + 6.9);
double y = static_cast<double>(123 + 321);
std::cout << x << " " << y; //13 444
```

Когато преобразуваме от `double` в `int`, `int`-ът приема само цялата част на `double`-а.

>### Символен тип (char) и ASCII таблица:

- Създаване на променлива от тип **char**: Използваме единични кавички `' '`, защото двойните `" "` са запазени за символни **низове**.
```c++
char symbol = 'A';
```

- На всеки символ от ASCII таблицата съответства цяло число
![ASCII Table](https://www.asciitable.com/asciifull.gif)

## III. Вградени функции и операции с числа

|         Операция        |               Оператор               |         Пример        |
|:-----------------------:|:------------------------------------:|:---------------------:|
|         Събиране        |                   +                  |          1+2          |
|        Изваждане        |                   -                  |          3-2          |
|        Умножение        |                   *                  |          2*3          |
|   Целочислено деление   |     / (операндите са цели числа)     |       3 / 5 == 0      |
|   Остатък при деление   |                   %                  |      11 % 2 == 1      |
|         Деление         | / (поне един от операндите е double) | (double)11 / 2 == 5.5 |
|       Степенуване       |               pow(x, n)              |     pow(3,3) == 27    |
|    Закръгляне отдолу    |               floor(x)               |    floor(5.5) == 5    |
|    Закръгляне отгоре    |                ceil(x)               |     ceil(5.5) == 6    |
|     Корен квадратен     |                sqrt(x)               |     sqrt(16) == 4     |
| Тригонометрични функции |         sin(x), cos(x), etc.         |      cos(0) == 1      |
|

## IV. Логически операции

Повече за операциите по ДСТР :)
|  Операция | Оператор |          Пример         |
|:---------:|:--------:|:-----------------------:|
| Конюнкция |    &&    |  true && false == false |
| Дизюнкция |   \|\|   | true \|\| false == true |
|

## V. Побитови операции

Двоичната бройна система е бройна система с основа 2, при която числата се изобразяват с помощта на 0 и 1.

На числото `x` в десетичната бройна система съответства `z` в двоична.

Когато трябва да обърнем число от десетична в двоична използваме следния метод:
> 1. Делим първоначалното число на 2
> 2. Ако то се дели без остатък записваме 0
> 3. Ако числото има остатък записваме 1
> 4. Връщаме се на стъпка 1., докато не достигнем 0.  

> Пример:
>|    Делене   | Остатък |
>|:-----------:|:-------:|
>| 22 / 2 = 11 |    0    |
>|  11 / 2 = 5 |    1    |
>|  5 / 2 = 2  |    1    |
>|  2 / 2 = 1  |    0    |
>|  1 / 2 = 0  |    1    |   
Остатъците се записват отдолу нагоре, т.е 10110

### Таблица на побитовите операции: 

| \| (bitwise OR)  | Взема две числа в двоичен запис и прилага операцията OR на всеки бит.                  |
|------------------|----------------------------------------------------------------------------------------|
| & (bitwise AND)  | Взема две числа в двоичен запис и прилага операцията AND на всеки бит.                 |
| ^ (bitwise XOR)  | Взема две числа в двоичен запис и прилага операцията XOR на всеки бит.                 |
| ~ (bitwise NOT)  | Взема едно число в двоичен запис и заменя всеки негов бит с противоположния му.        |
| >> (right shift) | Взема едно число в двоичен запис и премества битовете му с даден брой позиции надясно. |
| << (left shift)  | Взема едно число в двоичен запис и премества битовете му с даден брой позиции наляво.  |

## VI. Условен оператор if.

Кога използваме `if` оператора? 
> Когато искаме дадана част от програмата ни да се изпълни само ако е удовлетворено дадено условие.

### Има три вариации на `if` оператора в C++:

```c++
if (<условие>){
    <действия>;
}
// <условие> е булев израз
// <действия> е последователност от действия които искаме да се извършат ако <условие>-то е изпълнено
```

```c++
if (<условие>){
    <действия1>;
}
else{
    <действия2>;
}
// <условие> е булев израз
// <действия1> е последователност от действия които искаме да се извършат ако <условие>-то е изпълнено
// <действия2> е последователност от действия които искаме да се извършат ако <условие>-то НЕ Е изпълнено
```

```c++
if (<условие1>){
    <действия1>;
}
else if(<условие2>){
    <действия2>;
}
else if(<условиеX>...){
    <действияX>;
}
else{
    <действияN>;
}
// <условие i> е булев израз
// <действия1> е последователност от действия които искаме да се извършат ако <условие>-то е изпълнено
// <действияN> е последователност от действия които искаме да се извършат ако <условие>-то от 1 до X НЕ Е изпълнено

//В момента, в който едно от <условия>-та е изпълнено и се изпълнят съответните <действия> проверката в if-a приключва.
```

## VII. Тернарен оператор (Ternary operator)

Кога използваме тернарния оператор?

> Ако имаме една кратка операция, която искаме да се извърши в случай, че условието е изпълнено, и още една, в случай, че условието не е изпълнено.
> Често се използва, когато имаме нужда от `if - else` statement, но действията в `if` и `else`-а са кратки.
> 
> **NB** 
> 
> Тернарният оператор връща резултат, т.е можем да присвоим върнатото от него на проеменлива 
> 
> **NB**

### Синтаксис:

1. (<условие>) ? <оператор1> : <оператор2>
    - Ако условието е изпълнено се изпълнено, се изпълнява <оператор1>, ако условието НЕ Е изпълнено, се изпълнява <оператор2>.

    ```c++
    int x = 30;
    std::cout << (x == 30) ? true : false;
    // В случая ще се изпише true, защото условието е изпълнено.
    ```

2. <променлива> = (<условие>) ? <стойност1> : <стойност2>
    - Ако условието е изпълнено, на променливата се присвоява <стойност1>, ако условието НЕ е изпълнено, се присвоява <стойност2>.
    ```c++
    int x = 24;
    bool isEqualTo22 = (x == 22) ? true : false;
    std::cout << isEqualTo22; //0 (false)
    // В случая ще се изпише 0, защото условието не е изпълнено и булевата променлива приема стойност false.
    ```
## VIII. Switch оператор

Кога използваме оператора switch?

>Например когато имаме някаква променлива и предварително ни е известно точните стойности, които тя може да приема. Според тези точни стойности, може да изпълним различни действия в програмата на база, коя е стойността.

### Синтаксис: 
```c++  
switch (<израз_за_сравнение>){
    case <израз1> : <действия1>; break;
    case <израз2> : <действия2>; break;
    //... 
    case <изразN> : <действияN>; break;
    default: <действия(N+1)>;
} 
// break и default са опционални
// <израз_за_сравнение> е израза, според чиято стойност ще определим, кои случай (case-ове) ще се изпълнят
// case е запазена дума, break и default също
// <израз i> е константен израз (такъв който не съдържа променливи)
// default ще се изпълни когато стойноста на <израз_за_сравнение> не е налична в нито един от случаите case <израз i> i = 1..N
```
### А как работи оператора Switch?

1. Влизаме в Switch-a и изчисляваме стойността на <израз_за_сравнение>
2. Започва да върви ред по ред на случаите (*case*-овете). В общия случай, когато влезем в случай номер **k** case<израз**К**> се изпълнява следното:
   - Ако стойността на <израз**К**> е равна на стойността на <израз_за_сравнение> се изпълняват <действия**K**>
      - Ако накрая на <действия**К**> има `break`, изпълнението на switch-a спира.
      - Ако накрая на <действия**K**> **НЯМА** думата `break`, се изпълняват всички <действия> след **К**-тия *case* (случай) докато не се срещне думата `break`. Ако не се срещне `break` ще се изпълнят всички случай до `default`-ния (включително).
    - Ако стойността на <израз**К**> **НЕ Е** равна на стойността на <израз_за_сравнение> продължаваме към следващия *case* (случай).
3. Ако стойността на <израз_за_сравнение> не е равна на нито една от стойностите на <израз**К**> за всяко **К**, се изпълнява операторът на `default`.

```c++
int switchValue = 2;
switch(switchValue){
    case 1: std::cout << "Случай при 1. \n";
    case 2: std::cout << "Случай при 2. \n";
    default: std::cout << "Default case. \n";
}
//Изходът ще бъде:
// Случай при 2.
```

