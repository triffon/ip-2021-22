# Двумерни масиви

Двумерните масиви могат да се приемат като масив, чиито елементи също са масиви. 
- Както при едномерните, елементите им са от един и същи тип и са разположени последователно в паметта. 
- Броенето на елементите отново започва от 0.

## Декларация

Прието е да се мисли за двумерните масиви като за матрица.   
 Размерът ѝ трябва да е известен по време на компилация.
```c++
const unsigned ROWS = 2; //броя на редовете в матрицата
const unsigned COLS = 4; //броя на колоните

int arr[ROWS][COLS];
```
Този код декларира 
- матрица с 2 реда и 4 колони от елементи от тип `int`     
- масив с два елемента, всеки от които е масив с по 4 елемента от тип `int`. 

Крайният брой елементи е 2 * 4 = 8.

## Инициализация
- Можем да обиколим елементите един по един:
```c++
for(int i = 0; i < ROWS; ++i)
    for(int j = 0; j < COLS; ++j)
        std::cin >> arr[i][j];
```

- Можем да инициализираме при декларацията:
```c++
int arr[2][2] = { 1, 2, 3, 4 };

int arr[2][2] = { //това е по-четлив вариант на горното
    {1, 2},
    {3, 4} 
};

int arr[][2] = { 1, 2, 3, 4 };  //можем да не задаваме броя на редовете
```
- *НЕ МОЖЕМ да не дадем броя колони*
```c++
int arr[][] = { 1, 2, 3, 4 };  //НЕ!!!!
```
## Указатели
При едномерните масиви `int arr[] = { 1, 2 }` знаем, че:
- `arr` всъщност e указател и сочи първия елемент от масива. 
- `arr` е равно на адреса, на който е записано `1`   
- `*arr` е самата стойност `1`. 

При двумерните масиви `int arr[][2] = { {1, 2}, {3, 4} }`:
-  `arr` е указател към указател и сочи първия елемент на двумерния масив, който е едномерен масив.
- `arr` е равно на адреса, на който е записано `arr[0]` 
- `*arr` е адреса, на който е записано `1`, a `**arr` е самата стойност `1`.

## Достъпване на елементи
```c++
const int N = 4;

int arr[N][N] = {
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 },
    { 9, 10, 11, 12 },
    { 13, 14, 15, 16 }
};

std::cout << arr[1][2]; // '7'
// първата скоба казва кой ред гледаме
// втората - кой елемент

std::cout << *(*(arr + 1) + 2);
// *(arr + 1) е указател към елемент 0 на ред 1
// *(arr + 1) + 2 е указател към елемент 2 на ред 1
// *(*(arr + 1) + 2) e стойността '7'

std::cout << **((arr + 1 * N) + 2);
// това ще иска да вземе стойността на елемент 0 от 7 ред
// и ще е извън размерите на масива
```
### Главен диагонал
От алгебрата знаем, че елементите от главния диагонал имат еднакви първи и втори индекс.
```c++
for(int i = 0; i < N; ++i)
    std::cout << arr[i][i] << ' ';
// 1 6 11 16
```

### Страничен диагонал
Индексите на страничния диагонал имат сбор n + 1. 
```c++
for(int i = 0; i < N; ++i)
    std::cout << arr[i][N - 1 - i] << ' ';
// 4 7 10 13
```

## Функции
Можем да подаваме многомерните масиви като аргументи на функции по следните начини:

- Чрез `int arr[][MAX_COLS]` - двумерен масив от тип `int`.   
 Аналогично е на `int arr[]` при едномерните, само че *задължително* казваме броя на колоните, т.е. дължината на всеки ред.

```c++
const int MAX_ROWS = 1024;
const int MAX_COLS = 1024;

void printMatrix(int arr[][MAX_COLS], int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
		for (int j = 0; j < cols; ++j)
			std::cout << arr[i][j] << ' ';
		std::cout << std::endl;
	}
}
```
- Чрез `int (*arr)[MAX_COLS]` - указател към първия елемент на двумерния масив - едномерен масив от тип `int` с размер MAX_COLS
```c++
void printMatrix(int (*arr)[MAX_COLS], int rows, int cols) {
	//...
}
```
*НЕ МОЖЕМ* да подаваме многомерни масиви със статичен размер така:
- Чрез `int* arr[MAX_COLS]` - едномерен масив с размер MAX_COLS, съдържащ указатели към първите елементи на масиви с неясно какъв размер
```c++
void printMatrix(int* arr[MAX_COLS], int rows, int cols) {
	//...
}
```
- Чрез `int** arr` - указател към указател към първия елемент на масив с неясно какъв размер
```c++
void printMatrix(int** arr, int rows, int cols) {
	//...
}
```

# Динамично заделена памет
Динамичната памет се управлява не чрез променливи, а чрез указатели, които сочат на определено място в паметта, което можем да достъпим само през тях. Тази памет се *заделя* ръчно и се *освобождава* ръчно чрез операторите `new`, `new []` (за масиви) и `delete`, `delete[]` (за масиви).

- `int* ptr = new int;` създава на стека указател с име `ptr`, който в себе си съдържа адреса на една клетка от тип `int`, която се намира в heap-а. Чрез `new` ние резервираме тази конкретна клетка за наше ползване.

- `delete ptr;` освобождава клетката, към която ptr е сочил досега. Тя вече може да се използва от друг процес. В този момент `ptr` отново е неинициализиран указател и не е редно да се ползва.

- `int* ptr = new int[n];` създава на стека указател с име `ptr`, който в себе си съдържа адреса на първата клетка от масив от тип `int`. Понеже сме използвали `new []`, компилаторът знае, че `ptr` сочи към масив. В heap-a сме "резервирали" памет за n елемента от тип `int`, които са наредени последователно.

- `delete[] ptr;` освобождава *всички* n клетки, които сме заделелили с `new[]`. Ако използваме само `delete` ще освободим само първата от тях и останалите n-1 ще "висят" резервирани и без никакъв достъп до тях, защото вече ptr не сочи натам. 

## Примери
- Заделяне на едномерен масив с точен размер
```c++
int n;
std::cin >> n;

int* arr = new int[n];
//Вече можем да правим това!

//...ползваме си масива за нещо...

//освобождаваме веднага щом спре да ни трябва
delete[] arr;
```
- Заделяне на двумерен масив с точен размер
```c++
int n, m;
std::cin >> n >> m;

int** matrix = new int*[n];

for(int i = 0; i < n; ++i)
    matrix[i] = new int[m];

//...ползваме си матрицата за нещо...

//освобождаваме веднага щом спре да ни трябва
for(int i = 0; i < n; ++i)
    delete[] matrix[i];

delete[] matrix;
```
- Заделяне на масив по даден низ
```c++
const unsigned MAX_LEN = 1024;
//...

char buffer[MAX_LEN];
std::cin.getline(buffer, '\n');

char* str = new char[strlen(buffer) + 1];
//+1 заради '\0' накрая
strcpy(str, buffer);

//...ползваме str 

delete[] str;
```
- Функции, които връщат "масиви"
```c++
int evenCount(int* arr, int size){
    int count = 0;
    for(int i = 0; i < size; ++i)
        if(arr[i] % 2 == 0)
            count++;
    
    return count;
}

int* getEvenElements(int* arr, int size){
    int* evens = new int[evenCount(arr, size)];

    for(int i = 0, j = 0; i < size; ++i)
        if(arr[i] % 2 == 0){
            evens[j] = arr[i];
            j++;
        }
	
    return evens;
}

int main(){
    int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8 };

    int* evens = getEvenElements(arr, 8);
    //За да можем да го ползваме, все пак ще трябва да имаме и размера му
    int evensSize = evenCount(arr, size);

    delete[] evens;
    return 0;
}
```
## nullptr

`nullptr` означава, че указателят не сочи към нищо. Добра практика е преди да се задели памет и след като се освободи, пойнтърите, които сме използвали да я достъпваме да бъдат приравнени на това. Иначе сочат към произволно място в паметта, което не е наше за ползване.

```c++
int* ptr = nullptr;
ptr = new int;

delete ptr;
ptr = nullptr;
```
Това ни позволява и да проверяваме дали пойнтъра сочи към нещо

```c++
if(p)
    //...
```
## nothrow
Когато заделяме динамична памет, е възможно в този момент операционната система да няма достатъчно свободна памет, която да ни даде за ползване. Тогава оператор `new` ще хвърли изключение.

За да избегнем това, засега ще използваме аргумента `std::nothrow` на оператора `new`. Така вместо да хвърля изключение, връща `nullptr`.

```c++
int* p = new (std::nothrow) int[12];

if(!p){
    std::cout << "Allocation failure!\n";
}
```
## Течове на памет
- Когато забравим да изтрием заделена памет
- Когато не използваме правилния `delete[]` оператор
- Когато местим указателя
```c++
char* str = new char[...]; //някакъв низ
int lowercase = 0;

while(*str){ //докато не стигнем '\0'
    if(*str >= 'a' && *str <= 'z')
        lowercase++;
    str++;
}

std::cout << lowercase;

delete[] str;
//тук str вече сочи последния елемент от масива, а не първия и няма как да изтрие целия масив
```
