## Вложени цикли

Когато в тялото на един цикъл се изпълнява друг, казваме, че циклите са вложени. Всички видове цикли могат да се влагат един в друг - for във for, dowhile във for, while в do while, etc. 
```c++
for(int i = 0; i < n; ++i){
    //Код преди втория цикъл
    
    for(int j = 0; j < n; ++j){
        //Код на втория цикъл
    }
    //Код след втория цикъл
}
```
#### Как работи това?

По стандартния начин, по който работи for, като:  
- Първо се изпълнява кодът преди втория цикъл
- Вторият цикъл се изпълнява изцяло с всичките възможни итерации
- Изпълнява се кодът след втория цикъл
- Преминава се към следваща итерация на първия цикъл

#### Примери:

- Ако искаме да принтираме следната картинка:

```
   1
  12
 123
1234
...
до 9
```
```c++
for(int i = 0; i < n; ++i){
    //Принтираме спейсовете
    for(int j = n - i - 1; j > 0; j--)
        std::cout << ' ';
    
    //Принтираме числата
    for(int j = 0; j <= i; j++)
        std::cout << j + 1;
        
    std::cout << std::endl;
}
```
- Ако искаме да принтираме часът ако той е например 11:58:01:

```c++
for(int hours = 0; hours < 24; ++hours)
    for(int minutes = 0; minutes < 60; ++minutes)
        for(int seconds = 0; seconds < 60; ++seconds)
            if(hours == 11 && minutes == 58 && seconds == 1){
                if (hours < 10) std::cout << '0' << hours;
                else std::cout << hours;

                std::cout << ':';

                if (minutes < 10) std::cout << '0' << minutes;
                else std::cout << minutes;

                std::cout << ':';

                if (seconds < 10) std::cout << '0' << seconds;
                else std::cout << seconds;
            }
```
- Ако искаме докато въвеждаме n на брой числа, да принтираме цифрите им в обратен ред:

```c++
unsigned n;
std::cin >> n;

unsigned current = 0;

while(n){
    std::cin >> current;
    
    while(current){
        std::cout << current % 10;
        current /= 10;
    }
    
    n--;
}
```

## Масиви

Масивите са колекция от елементи от един тип, които са разположени последователно в паметта и имат поредни индекси, с които можем да достъпим всеки елемент.
Пишем `<тип> <име>[<размер>]`, като размерът трябва да ни е известен по време на компилация. 

```
int arr[5];
```
```
const unsigned ARR_LEN = 5;
char char_arr[ARR_LEN];
```
Можем и да подадем експлицитно стойности, с които да се инициализират елементите - компилаторът ще разбере, че размерът на масива ще е 3.
```
unsigned arr[] = {1, 2, 3};
```
Можем да дадем размер и да подадем стойности. Ако те не съвпадат по брой с размера, компилаторът ще допълни масива с нули.
```
unsigned arr[5] = {1, 2, 3}; //[1, 2, 3, 0, 0]
```

Какво да НЕ правим:
```
int n;
std::cin >> n;

int arr[n];
```
Този масив използва статично заделена памет (повече за това като учим динамично заделяне на памет), съответно трябва да знаем размера му по време на компилация.

### Индексиране:

Достъпването на елементите става с `<име>[<индекс на елемента>]`:

```
int arr[5] = {1, 20, 31, 49, 53};

for(int i = 0; i < 5; ++i)
    std::cout << arr[i] << " ";
    
//1 20 31 49 53
```
НО започваме да броим индексите от нула до n-1:
```
std::cout << arr[5]; //това ще даде грешка, защото имаме 5 елемента,
                     //но с индекси от 0 до 4
```

Можем да променяме стойностите на елементите:
```
int arr[5] = {1, 20, 31, 49, 53};

arr[0] = 12;
std::cout << arr[0]; //12
```
## Сортиране

### Bubble Sort
Минаваме през масива и сравняваме два по два елементите, като ги разменяме ако не са в правилния ред. С всяка итерация на външния цикъл, най-големия или най-малкия елемент "изплува" като балон в края/началото на масива. 

```
for (int i = 0; i < n - 1; i++)
        for (int j = 0; j < n - i - 1; j++) //най-големия елемент e "изплувал"
                                            //най-отзад и считаме, че масивът е
                                            //сортиран след n - i - 1
            if (arr[j] > arr[j + 1]){
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
```

### Selection Sort
Разделяме масива на сортирана (първоначално празна) и несортирана (първоначално съдържаща всички елементи) част. Алгоритъмът минава през несортирания подмасив и търси най-малкия елемент. Когато го намери, го разменя с елемента в началото на този подмасив и премества границата така, че тази позиция вече да е част от сортирания подмасив.

```
int min_index = 0;

for (int i = 0; i < n - 1; ++i) {
	min_index = i;
	for (int j = i + 1; j < n; ++j) { //до i + 1 вече всички са сортирани
		if (arr[j] < arr[min_index])
			min_index = j;
	}

	if (min_index != i) {
		int temp = arr[i];
		arr[i] = arr[min_index];
		arr[min_index] = temp;
	}
}
```