# Функции

## Декларация на функция

Един от главните начини да свършим дадена работа в една програма е да извикаме **функция**, за да я свърши. Функциите не могат да бъдат **извикани** без преди това да са били **декларирани** (по-долу ще видим и как се **дефинира**).
- Декларацията на функция съдържа име на функцията, типа на връщания резултат (ако има такъв), и броя и типа на аргументите, които се подават при извикаване на функцията
```C++
void exit(int); // int argument, return nothing
double sqrt(double); //double argument, return double
```
- Декларацията на функцията може да съдържа и **имена** на аргументите (освен техния тип), тези имена помагат на този, който чете кода и трябва да подаде същинските променливи на мястото на тези аргументи.
  - Тип на връщания резултат `void` означава, че функцията не връща никакъв резултат.
  - Задължителните компоненти в една декларация са: *име на функцията*, *списък на аргументите, може да бъде празен*, *тип на връщания резултат*.

## Дефиниция на функция

Всяка функцията, която извикваме трябва да бъде **дефинирана** някъде (функция се дефинира само веднъж). 
- Дефиниция на функция е декларация на функция в която е написано и тялото на функцията. Например:
```C++
int sum(int, int); // a declaration

int sum(int a, int b)   // a definition
{
    int sum = a + b;    //perform some operations
    return sum;         //here we return the result of the function (int)
}
```
- Дефиницията и декларацията на фунцкията трябва да бъдат с еднакво съдържание.
  - **Важна теоретична забележка** `const` се игнорира на ниво тип на аргументите,(не можем да различим две еднакви функции с разлика в наличието на const) т.е:
```C++
//Тези две декларации са на една и съща функция:
void f(int); //type is void(int)
void f(const int); //type is void(int)

//Обаче:
//Функцията f() може да бъде ДЕФИНИРАНА така:
void f(int x) { /* we can modify x here */ }
//Алтернативно може да бъде ДЕФИНИРАНА така:
void f(const int x) { /*we cannot modify x here */ } 
```
  - В двата случая аргумента, който f() може/не може да променя е копие на подадения аргумент, който викащия функцията е подал, така че няма опасност да се модифицира обект, който не трябва.

## Връщане на резултат от функция

- Всяка декларация на функция съдържа типа на връщания от функцията резултат. Попринцип типът на връщания резултат стой в началото на декларацията, но има и възможност той да бъде след списъка с аргументи:
```C++
int id(int a); //prefix return type
auto id(int a)->int //suffix return type  (нека не използваме това в курса по УП)
/*
Ключовата дума `auto` индикира, че типа на връщания резултат ще бъде след списъка с аргументи на фунцкията и типа на връщания резултат се предшества от `->`
*/
// дадено е само информативно :)
```

- Функция която не връща резултат има тип на връщания резултат `void`.
- Функции с всякакъв друг тип на връщания резулат ТРЯБВА да върнат стойност.
- Например:
```C++
int f1() {  }   //error: no value returned
void f2() {  }  // OK

int f3() {return 1;} //OK
void f4() {return 1;} //error: return value in void function

int f5() {return;} //error: return value missing
void f6() {return;} // OK
```

- В общия случай при всяко извикване на функция се създават (локални променливи) копия на нейните фактически аргументи, които съществуват само в тялото на функцията и се унищожават след приключване на функцията.

- Функция която извиква себе си се нарича **рекурсивна**.

### Локални променливи 

- Освен ако променливата не е декларирана като **static** всяко извикване на функцията има свое свобствено копие на променливите. Ако локалната променлива е декларирана като **static**, един единствен статично заделен обект ще се използва, за всяко извикване на функцията и неговата стойност ще се запазва. Той ще се инициализира само при първото извикване на функцията. Например: 
```C++
void f(int a){
    while(a--){
        static int n = 0;   //initialized once
        int x = 0;          //initialized 'a' times in each call of f()

        std::cout << "n = " << n++ << ", x = " << x++ << '\n';
    }
}

int main()
{
    f(3);

    return 0;
}

/*
Output: 
n = 0, x = 0
n = 1, x = 0
n = 2, x = 0 
*/
```
    - Статичната променлива позволява на функцията да запазва информация между извикванията без да се създава глобална променлива, която може да бъде променяна от други функции.
  - Поведението при дефиниране на статична промнелива рекурсивно е недефинирано. Например:

```C++
int fn(int n){
    static int n1 = n; //OK
    static int n2 = fn(n - 1) + 1; //UNDEFINED
    return n;
}
```

## Видове аргументи

Когато извикаме функция с `ime ()` се заделят памет за формалните ѝ параметри и всеки от тях се инициализира с истинските аргументи подадени на функцията, като на общо основание те се копират и казваме че се подават **по стойност**. Подавайки истинските аргументи типовете им се сравняват с формалните и ако са различни и е възможно **cast-ване** се извършва.

- Единственото изключение от правило за копиране на истинските параметри е когато подаваме нещо по **референция**.

### Аргументи по референция

Нека имаме функцията:
```C++
void f(int val, int &ref){
    ++val;
    ++ref;
}
/*
Когато f() се извика, ++val увеличава ЛОКАЛНОТО КОПИЕ НА ПЪРВИЯ АРГУМЕНТ, а ++ref увеличава фактическия втори аргумент.
Т.е стойноста на val след извикването на функцията ще остане същата, а тази на ref ще се увеличи с 1.
*/
```

### Аргументи, които са масиви

Ако се използва масив за аргумент на функция, то се всъщност се подава **указател към първия елемент**. Например:
```C++
int strlen(const char*);

void f()
{
    char v[] = "Nikolay";
    int i = strlen(v);
    int j = strlen("Georgi");
}
/*
Тоест подаваме не масив по стойност, а указател към първия елемент по стойност.
Следната еквивалентност е в сила:
*/
//Тези 3 функции са еквивалентни и декларират една и съща функция (имената на променливите не влиаят на типа на функцията).
void odd(int* p);
void odd(int a[]);  
void odd(int buff[256]);

```

## Overloaded functions
Често е добра идея да даваме на различните функции различни имена, но когато някои различни функции вършат една и съща работа, но за обекти от различен тип, би било по удобно да им дадем същото име. Този процес се нарича `overloading`. Идеята е както може да използваме оператора `+` за int, double, и други типове данни, така тази идея се пранася и за функции, например:
```C++
void print (int); //print an int
void print (char); //print a char
void print (double); //print a double
void print (int*); // print an integer array (more about it later)
```

Когато извикаме функцията `print`, компилатора трябва да определи, коя от всички функции с име `print` да извика. Това става посредством сравнение на типовете на фактическите параметри (които сме подали при извикването на функцията) с типовете на всички функции с име `print`. Идеята е да се извика фунцкията, която най-много пасва на подадените аргументи и ако няма такава да се "хвърли" грешка при компилиране. Например:
```C++
void print(double);
void print(long);

void f()
{
    print(1L); //print(long)
    print(1.0); //print(double)
    print(1); //error, ambiguous: print(long (1)) or print(double(1))
}
```
Оценяването за това, коя функция да се извика става по следните критерии в следната последователност:
1. Съвпадат напълно, съвпадат използвайки само тривиални преобразувания (напр. име на масив към указател, type към const type)
2. Съвпадат използвайки `promotions`, това са `integral promotions` (bool to int, char to int, short to int) и техните `unsigned` аналози.
3. Съвпадат използвайки стандартни преобразувания (int to double, double to int, double to long double, (ако са класове *ще говорим по нататък* Derived* to Base*), int to unsigned int и тн.)
4. Съвпадат използвайките дефинирани от програмиста преобразувания
5. Не е от този курс
Пример:
```C++
void print(int);
void print(const char∗);
void print(double);
void print(long);
void print(char);

void h(char c, int i, short s, float f)
{
print(c); // exact match: invoke print(char)
print(i); // exact match: invoke print(int)
print(s); // integral promotion: invoke print(int)
print(f); // float to double promotion: print(double)

print('a'); // exact match: invoke print(char)
print(49); // exact match: invoke print(int)
print(0); // exact match: invoke print(int)
print("a"); // exact match: invoke print(const char*)

print(nullptr); // nullptr_t to const char* promotion: invoke print(cost char*) //ще говорим за указатели
}
```
- Типа на връщания резултат не участва в определянето на коя функция да се вземе. Например:
```C++
float sqrt(float);
double sqrt(double);

void g(double d, float f)
{
    float fl = sqrt(d); //call sqrt(double)
    double db = sqrt(d); //call sqrt(double)

    fl = sqrt(f); //call sqrt(float)
    db = sqrt(f); //call sqrt(float)
}
```


# Указатели, динамични масиви и референции

## Указатели
За тип `T`, `T*` е тип: "указател към Т". Т* е променлива, която може да държи адрес на обект от тип Т. Например:
```C++
char c = 'a';
char* p = &c;  // p държи адреса на `c`; & e оператора за "address-of"
```

Основната операция с указатели е дереференцирането `dereferencing`, което означава, да вземем обекта сочен от указателя. Оператора, който се използва за дереференциране е префиксна звезда (*). Например:
```C++
char c = 'a';
char* p = &c; //p holds the address of c, & is the address-of operator
char c2 = *p; // c2 == 'a', * is the dereference operator
```

### Nullptr 

`nullptr` представлява указател, който не сочи към обект. Може да бъде стойност на всеки тип указатели, но не и на "не-указателни" типове:
```C++
int* pi = nullptr;
double* pd = nullptr;
int i = nullptr; //error: i is not a pointer
```
- нулевия указател е един и той се използва за всички видове указатели.

## Динамични масиви

Един масив може да бъде заделен статично (на стека) или динамично (на heap-а). Например:
```C++
void f()
{
    int a1[20];             //20 ints on the stack
    int* p = new int[40];   //40 ints on the heap
}
```

Важно е след като заделим масив на heap-а след като приключим с използването му да го изтриваме с командата `delete[];`

## Указатели в масиви
В C++ указателите и масивите са тясно свързани. Името на един масив може да бъде използвано като указател към неговия първи елемент. Например:
```C++
int v[] = {1,2,3,4};
int* p1 = v; //указател към първия елемент (неявно преобразуване)
int* p2 = &v[0]; //указател към първия елемент
int* p3 = v+4; //указател към елемента след последния елемент
```

## Референции

Референциите `&` ни дават възможност да подаваме параметри на функции без те да се копират и така ги променяме подредством функцията

Пример:
```C++
void addThree(int number){
    number += 3;
}

void addThreeRef(int& number){
    number += 3;
}

int main()
{
    int number = 1;
    addThree(number); // number is again 1
    addThreeRef(number); //number is again 4
    
    return 0;
}
```

# C-style Strings (низове)

> String-овете са дефинирани като масиви от символи, но разликата когато кажем **масив от символи** и **низове** е че низовете винаги завършват със специалния символ `\0`, още го наричаме терминираща нула.

## Инициализация на символни низове:
- Един низ може да се инициализира по различни начини, нека видим следните примери:
```cpp
//1-ви начин
char str[] = "IntroToProgramming";
//2-ри начин
char str[50] = "IntroToProgramming";
//3-ти начин
char str[] = {'I','n','t','r','o','T','o','P','r','o','g','r','a','m','m','i','n','g','\0'};
//4-ти начин
char str[19] = {'I','n','t','r','o','T','o','P','r','o','g','r','a','m','m','i','n','g','\0'};
```

- Инициализирайки низовете по този начин, имаме възможността да принтираме "масива на конзолата" директно използвайки `std::cout`

## Основни функции за работа със символни низове:
- strcpy(char* str1, char* str2) -> копира str2 в str1
- strcat(char* str1, char* str2) -> конкатенира str2 към str1
- strlen(char* str1) -> връща дължината на символния низ
- strcmp(char* str1, char* str2) -> сравнява лексикографски два низа, и връща 0 ако са равни, <0 ако втория е по-голям и >0 ако първия е по-голям

```
int myStrLen(char* str) {
	int size = 0;
	while (str[size] != '\0') {
		size++;
	}
	return size;
}
//!!! Напишете останалите споменати по-горе сами !!!
```

## Въвеждането на низове
- Става посредством функциите за вход като те сами поставят терминираща нула `\0`
  - std::cin
  - std::cin.getline(...) Ще покажем особеностите в пример.

