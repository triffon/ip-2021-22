#include <iostream>
#include <cstring>
#include <cstdlib>

using namespace std;

//------------------------------------------------------------------------------
// Функция която връща главна буква при подадена малка.
// Ако не е малка буква връща същия символ.
// Пример: f -> F
//------------------------------------------------------------------------------
char toUpper( char ch )
{
    if ( ch >= 'a' && ch <= 'z' )
        return ch - ( 'a' - 'A' );

    return ch;
}

//------------------------------------------------------------------------------
// Напишете функция, променя всички малки букви в главни в подаден символен низ.
// Пример: abCDeef45_go!?+%t12 -> ABCDEEF45_GO!?+%T12
//------------------------------------------------------------------------------
void toUpper( char str[] )
{
    int i = 0;
    while ( str[ i ] != '\0' )  // Еквивалентно на while ( str[ i ] )
    {
        str[ i ] = toUpper( str[ i ] );
        ++i;
    }
}

//------------------------------------------------------------------------------
// Напишете функция, която приема символен низ и го обръща наобратно.
// Пример: fmi -> imf
//------------------------------------------------------------------------------
void reverse( char str[] )
{
    int len = strlen( str );
    for ( int i = 0; i < len / 2; i++ )
        std::swap( str[ i ], str[ len - 1 - i ] );
}

//------------------------------------------------------------------------------
// Напишете функция, която проверява дали даден низ е палиндром.
// Пример: asdfdsa -> true
// Забележка: CONST char str[], тъй като няма да променяме символния низ!
//------------------------------------------------------------------------------
bool isPalindrome( const char str[] )
{
    int len = strlen( str );
    for ( int i = 0; i < len / 2; i++ )
        if ( str[ i ] != str[ len - 1 - i ] )
            return false;

    return true;
}

//------------------------------------------------------------------------------
// Реализирайте функцията atoi() за цели положителни числа.
// Пример: 001523g2 -> 1523
// Забележка: CONST char str[], тъй като няма да променяме символния низ!
//------------------------------------------------------------------------------
unsigned unsignedAtoi( const char str[] )
{
    // Пропускаме всякакви празни пространства от началото на символния низ
    int i = 0;
    while ( str[ i ] != '\0' && isspace( str[ i ] ) )
        ++i;

    // Четем само символи между '0' и '9'
    unsigned res = 0;
    while ( str[ i ] >= '0' && str[ i ] <= '9' )
    {
        res *= 10;
        res += str[ i ] - '0';
        ++i;
    }

    return res;
}

bool isLetter( char ch )
{
    return ( ch >= 'a' && ch <= 'z' ) || ( ch >= 'A' && ch <= 'Z' );
}

//------------------------------------------------------------------------------
// Напишете функция, която в даден низ прави всяка първа буква на дума главна.
//------------------------------------------------------------------------------
void capitalizeWords( char str[] )
{
    int i = 1;  // Започваме от 1 и ще проверяваме предишния символ.
    while ( str[ i ] != '\0' )  // Еквивалентно на while ( str[ i ] )
    {
        if ( !isLetter( str[ i - 1 ] ) )
            str[ i ] = toUpper( str[ i ] );

        ++i;
    }

    // Правим първата буква главна
    str[ 0 ] = toUpper( str[ 0 ] );
}

const int MAX_WORDS = 32;

//------------------------------------------------------------------------------
// Напишете функция, която по подаден низ връща масив от думите в низа.
// Забележка: За целта на задачата приемаме, че думи са всички поредици
// от латински букви отделени чрез какъвто и да е друг символ.
// Пример: FMI is     great!    ->    { "FMI", "is", "great" }
// Забележка: CONST char inStr[], тъй като няма да променяме символния низ!
//------------------------------------------------------------------------------
int getWords( const char inStr[], char outWordsArr[][ MAX_WORDS ] )
{
    int wordsCount = 0;
    int i = 0;

    do
    {
        int wordIndex = 0;

        // Докато текущият символ е буква -> записваме в масива от думи
        while ( isLetter( inStr[ i ] ) )
        {
            // Забележка: Ако искаме да считаме всяка поредица от каквито и
            // да било символи, разделени от някакъв white space за дума, то
            // условието на while-a би било: 
            // while ( inStr[ i ] && !isspace( inStr[ i ] ) )

            // Копираме символите в текущата дума
            outWordsArr[ wordsCount ][ wordIndex ] = inStr[ i ];
            ++wordIndex;
            ++i;
        }

        // Ако се прочели поне един сумвол за текущата дума
        if ( wordIndex > 0 )
        {
            // Терминираме текущата дума
            outWordsArr[ wordsCount ][ wordIndex ] = '\0';
            ++wordsCount;
        }
    }
    while ( inStr[ i++ ] );
    // Проверката inStr[ i++ ] е еквивалентна на inStr[ i++ ] != '\0'
    // Припомняне: Постфиксният оператор ++ първо ще използва текущата
    // стойност на променливата i и след това ще увеличи стойността ѝ.

    return wordsCount;
}

//------------------------------------------------------------------------------
int main()
{
    const int MAX_STRLEN = 128;

    char str[ MAX_STRLEN ];

    cin.getline( str, MAX_STRLEN );

    // Задача 1
    //toUpper( str );
    //cout << str << '\n';

    // Задача 2
    //reverse( str );
    //cout << str << '\n';

    // Задача 3
    //cout << boolalpha << isPalindrome( str ) << '\n';

    // Задача 4
    //int num = unsignedAtoi( str );
    //cout << num << ", num + 5 = " << num + 5 << '\n';

    // Задача 5
    //capitalizeWords( str );
    //cout << str << '\n';

    // Задача 6
    char wordsArr[ MAX_STRLEN ][ MAX_WORDS ];
    int wordCnt = getWords( str, wordsArr );
    
    for ( int i = 0; i < wordCnt; i++ )
        cout << wordsArr[ i ] << '\n';

    return 0;
}
